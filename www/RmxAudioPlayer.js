/**
* This file has been generated by Babel.
* 
* DO NOT EDIT IT DIRECTLY
* 
* Edit the JS source file src/js/push.js
**/
"use strict";

var _Constants = require("./Constants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*!
 * Module dependencies.
 */
var exec = cordova.require('cordova/exec');

var channel = cordova.require('cordova/channel'); // for debug, add these immediately after initializing the class.
// "https://rolamix-usercontent.s3.us-east-2.amazonaws.com/band-audios/5a4eec1e7b9b120ef9c8d528/coYiT0UlNJtnSv.mp3"
// "https://rolamix-usercontent.s3.us-east-2.amazonaws.com/band-audios/5a5d72f3617acf0e90de39b3/qeQM8hfanV143Q.mp3"


var AudioPlayer =
/*#__PURE__*/
function () {
  function AudioPlayer() {
    var _this = this;

    _classCallCheck(this, AudioPlayer);

    this.init = function (successCallback, errorCallback, options) {
      // we don't use this for now.
      _this.options = options || null;
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'initialize', [options]);
    };

    this.setPlaylistItems = function (successCallback, errorCallback, items) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'setPlaylistItems', [items]);
    };

    this.addItem = function (successCallback, errorCallback, trackItem) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'addItem', [trackItem]);
    };

    this.addAllItems = function (successCallback, errorCallback, trackItems) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'addAllItems', [trackItems]);
    };

    this.removeItem = function (successCallback, errorCallback, trackItem) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'removeItem', [trackItem]);
    };

    this.removeItems = function (successCallback, errorCallback, trackItems) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'removeItems', [trackItems]);
    };

    this.clearAllItems = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'clearAllItems', []);
    };

    this.play = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'play', []);
    };

    this.playTrackByIndex = function (successCallback, errorCallback, index) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'playTrackByIndex', [index]);
    };

    this.playTrackById = function (successCallback, errorCallback, trackId) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'playTrackById', [trackId]);
    };

    this.pause = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'pause', []);
    };

    this.skipForward = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'skipForward', []);
    };

    this.skipBack = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'skipBack', []);
    };

    this.seekTo = function (successCallback, errorCallback, position) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'seekTo', [position]);
    };

    this.seekToQueuePosition = function (successCallback, errorCallback, position) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'seekToQueuePosition', [position]);
    };

    this.setPlaybackRate = function (successCallback, errorCallback, rate) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'setPlaybackRate', [rate]);
    };

    this.setVolume = function (successCallback, errorCallback, volume) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'setPlaybackVolume', [volume]);
    };

    this.setLoop = function (successCallback, errorCallback, loop) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'setLoopAll', [!!loop]);
    };

    this.getPlaybackRate = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'getPlaybackRate', []);
    };

    this.getVolume = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'getPlaybackVolume', []);
    };

    this.getPosition = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'getPlaybackPosition', []);
    };

    this.getCurrentBuffer = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'getCurrentBuffer', []);
    };

    this.getTotalDuration = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'getTotalDuration', []);
    };

    this.getQueuePosition = function (successCallback, errorCallback) {
      exec(successCallback, errorCallback, 'RmxAudioPlayer', 'getQueuePosition', []);
    };

    this.handlers = {};
  }
  /**
   * Player interface
   */


  _createClass(AudioPlayer, [{
    key: "onStatus",

    /**
     * Status event handling
     */
    value: function onStatus(trackId, type, value) {
      var status = {
        type,
        trackId,
        value
      };
      console.log(`RmxAudioPlayer.onStatus: ${_Constants.RmxAudioStatusMessageDescriptions[type]}: ${value}`);
      this.emit('status', status);
    }
  }, {
    key: "on",
    value: function on(eventName, callback) {
      if (!Object.prototype.hasOwnProperty.call(this.handlers, eventName)) {
        this.handlers[eventName] = [];
      }

      this.handlers[eventName].push(callback);
    }
  }, {
    key: "off",
    value: function off(eventName, handle) {
      if (Object.prototype.hasOwnProperty.call(this.handlers, eventName)) {
        var handleIndex = this.handlers[eventName].indexOf(handle);

        if (handleIndex >= 0) {
          this.handlers[eventName].splice(handleIndex, 1);
        }
      }
    }
  }, {
    key: "emit",
    value: function emit() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var eventName = args.shift();

      if (!Object.prototype.hasOwnProperty.call(this.handlers, eventName)) {
        return false;
      }

      var handler = this.handlers[eventName];

      for (var i = 0; i < handler.length; i++) {
        var callback = this.handlers[eventName][i];

        if (typeof callback === 'function') {
          callback.apply(void 0, args);
        }
      }

      return true;
    }
  }]);

  return AudioPlayer;
}();

var playerInstance = new AudioPlayer(); // Initialize the plugin to send and receive messages

channel.createSticky('onRmxAudioPlayerReady');
channel.waitForInitialization('onRmxAudioPlayerReady');

function onNativeStatus(msg) {
  if (msg.action === 'status') {
    playerInstance.onStatus(msg.status.trackId, msg.status.msgType, msg.status.value);
  } else {
    throw new Error(`Unknown media action ${msg.action}`);
  }
}

channel.onCordovaReady.subscribe(function () {
  exec(onNativeStatus, undefined, 'RmxAudioPlayer', 'storeMessageChannel', []);
  channel.initializationComplete('onRmxAudioPlayerReady');
});
/*!
 * AudioPlayer Plugin.
 */

module.exports = {
  /**
   * AudioPlayer instance.
   */
  AudioPlayer: playerInstance,
  AudioErrorType: _Constants.RmxAudioErrorType,
  AudioErrorTypeDescriptions: _Constants.RmxAudioErrorTypeDescriptions,
  AudioStatusMessage: _Constants.RmxAudioStatusMessage,
  AudioStatusMessageDescriptions: _Constants.RmxAudioStatusMessageDescriptions
};